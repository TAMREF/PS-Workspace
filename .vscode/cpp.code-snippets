{
    "tamplate": {
      "scope": "cpp",
      "prefix": "tampl",
      "body": [
        "#include <bits/stdc++.h>",
        "#define va first",
        "#define vb second",
        "#define lb lower_bound",
        "#define ub upper_bound",
        "#define bs binary_search",
        "#define pp push_back",
        "#define ep emplace_back",
        "#define all(v) (v).begin(),(v).end()",
        "#define szz(v) ((int)(v).size())",
        "#define bi_pc __builtin_popcount",
        "#define bi_pcll __builtin_popcountll",
        "#define bi_tz __builtin_ctz",
        "#define bi_tzll __builtin_ctzll",
        "#define fio ios_base::sync_with_stdio(0);cin.tie(0);",
        "#ifdef TAMREF",
        "#define debug(...) fprintf(stderr, __VA_ARGS__)",
        "#else",
        "#define debug(...) 42",
        "#endif",
        "using namespace std;",
        "using ll = long long; using lf = long double; ",
        "using pii = pair<int,int>; using ppi = pair<int,pii>;",
        "using pll = pair<ll,ll>; using pff = pair<lf,lf>;",
        "using ti = tuple<int,int,int>;",
        "using base = complex<double>;",
        "const lf PI = 3.14159265358979323846264338L;",
        "template <typename T>",
        "inline T umax(T& u, T v){return u = max(u, v);}",
        "template <typename T>",
        "inline T umin(T& u, T v){return u = min(u, v);}",
        "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
        "",
        "int main(){",
        "}"
      ],
      "description": "cp-style template"
    },
    "berlekamp": {
      "scope": "cpp",
      "prefix": "bkamp",
      "body": [
        "const int mod = 998244353;",
        "using lint = long long;",
        "lint ipow(lint x, lint p){",
        "  lint ret = 1, piv = x;",
        "  while(p){",
        "    if(p & 1) ret = ret * piv % mod;",
        "    piv = piv * piv % mod;",
        "    p >>= 1;",
        "  }",
        "  return ret;",
        "}",
        "vector<int> berlekamp_massey(vector<int> x){",
        "  vector<int> ls, cur;",
        "  int lf, ld;",
        "  for(int i=0; i<x.size(); i++){",
        "    lint t = 0;",
        "    for(int j=0; j<cur.size(); j++){",
        "      t = (t + 1ll * x[i-j-1] * cur[j]) % mod;",
        "    }",
        "    if((t - x[i]) % mod == 0) continue;",
        "    if(cur.empty()){",
        "      cur.resize(i+1);",
        "      lf = i;",
        "      ld = (t - x[i]) % mod;",
        "      continue;",
        "    }",
        "    lint k = -(x[i] - t) * ipow(ld, mod - 2) % mod;",
        "    vector<int> c(i-lf-1);",
        "    c.push_back(k);",
        "    for(auto &j : ls) c.push_back(-j * k % mod);",
        "    if(c.size() < cur.size()) c.resize(cur.size());",
        "    for(int j=0; j<cur.size(); j++){",
        "      c[j] = (c[j] + cur[j]) % mod;",
        "    }",
        "    if(i-lf+(int)ls.size()>=(int)cur.size()){",
        "      tie(ls, lf, ld) = make_tuple(cur, i, (t - x[i]) % mod);",
        "    }",
        "    cur = c;",
        "  }",
        "  for(auto &i : cur) i = (i % mod + mod) % mod;",
        "  return cur;",
        "}",
        "int get_nth(vector<int> rec, vector<int> dp, lint n){",
        "  int m = rec.size();",
        "  vector<int> s(m), t(m);",
        "  s[0] = 1;",
        "  if(m != 1) t[1] = 1;",
        "  else t[0] = rec[0];",
        "  auto mul = [&rec](vector<int> v, vector<int> w){",
        "    int m = v.size();",
        "    vector<int> t(2 * m);",
        "    for(int j=0; j<m; j++){",
        "      for(int k=0; k<m; k++){",
        "        t[j+k] += 1ll * v[j] * w[k] % mod;",
        "        if(t[j+k] >= mod) t[j+k] -= mod;",
        "      }",
        "    }",
        "    for(int j=2*m-1; j>=m; j--){",
        "      for(int k=1; k<=m; k++){",
        "        t[j-k] += 1ll * t[j] * rec[k-1] % mod;",
        "        if(t[j-k] >= mod) t[j-k] -= mod;",
        "      }",
        "    }",
        "    t.resize(m);",
        "    return t;",
        "  };",
        "  while(n){",
        "    if(n & 1) s = mul(s, t);",
        "    t = mul(t, t);",
        "    n >>= 1;",
        "  }",
        "  lint ret = 0;",
        "  for(int i=0; i<m; i++) ret += 1ll * s[i] * dp[i] % mod;",
        "  return ret % mod;",
        "}",
        "int guess_nth_term(vector<int> x, lint n){",
        "  if(n < x.size()) return x[n];",
        "  vector<int> v = berlekamp_massey(x);",
        "  if(v.empty()) return 0;",
        "  return get_nth(v, x, n);",
        "}",
        "struct elem{int x, y, v;}; // A_(x, y) <- v, 0-based. no duplicate please..",
        "vector<int> get_min_poly(int n, vector<elem> M){",
        "  // smallest poly P such that A^i = sum_{j < i} {A^j \times P_j}",
        "  vector<int> rnd1, rnd2;",
        "  mt19937 rng(0x14004);",
        "  auto randint = [&rng](int lb, int ub){",
        "    return uniform_int_distribution<int>(lb, ub)(rng);",
        "  };",
        "  for(int i=0; i<n; i++){",
        "    rnd1.push_back(randint(1, mod - 1));",
        "    rnd2.push_back(randint(1, mod - 1));",
        "  }",
        "  vector<int> gobs;",
        "  for(int i=0; i<2*n+2; i++){",
        "    int tmp = 0;",
        "    for(int j=0; j<n; j++){",
        "      tmp += 1ll * rnd2[j] * rnd1[j] % mod;",
        "      if(tmp >= mod) tmp -= mod;",
        "    }",
        "    gobs.push_back(tmp);",
        "    vector<int> nxt(n);",
        "    for(auto &i : M){",
        "      nxt[i.x] += 1ll * i.v * rnd1[i.y] % mod;",
        "      if(nxt[i.x] >= mod) nxt[i.x] -= mod;",
        "    }",
        "    rnd1 = nxt;",
        "  }",
        "  auto sol = berlekamp_massey(gobs);",
        "  reverse(sol.begin(), sol.end());",
        "  return sol;",
        "}",
        "lint det(int n, vector<elem> M){",
        "  vector<int> rnd;",
        "  mt19937 rng(0x14004);",
        "  auto randint = [&rng](int lb, int ub){",
        "    return uniform_int_distribution<int>(lb, ub)(rng);",
        "  };",
        "  for(int i=0; i<n; i++) rnd.push_back(randint(1, mod - 1));",
        "  for(auto &i : M){",
        "    i.v = 1ll * i.v * rnd[i.y] % mod;",
        "  }",
        "  auto sol = get_min_poly(n, M)[0];",
        "  if(n % 2 == 0) sol = mod - sol;",
        "  for(auto &i : rnd) sol = 1ll * sol * ipow(i, mod - 2) % mod;",
        "  return sol;",
        "}"
      ],
      "description": "Berlekamp-Massey template code"
    },
    "linecontainer": {
        "scope": "cpp",
        "prefix": "lcont",
        "body": [
          "struct Line {",
          "  mutable ll k, m, p;",
          "  bool operator<(const Line& o) const { return k < o.k; }",
          "  bool operator<(ll x) const { return p < x; }",
          "};",
          "",
          "struct LineContainer : multiset<Line, less<>> {",
          "  // (for doubles, use inf = 1/.0, div(a,b) = a/b)",
          "  const ll inf = LLONG_MAX;",
          "  ll div(ll a, ll b) { // floored division",
          "    return a / b - ((a ^ b) < 0 && a % b); }",
          "  bool isect(iterator x, iterator y) {",
          "    if (y == end()) { x->p = inf; return false; }",
          "    if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
          "    else x->p = div(y->m - x->m, x->k - y->k);",
          "    return x->p >= y->p;",
          "  }",
          "  void add(ll k, ll m) {",
          "    auto z = insert({k, m, 0}), y = z++, x = y;",
          "    while (isect(y, z)) z = erase(z);",
          "    if (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
          "    while ((y = x) != begin() && (--x)->p >= y->p)",
          "      isect(x, erase(y));",
          "  }",
          "  ll query(ll x) {",
          "    assert(!empty());",
          "    auto l = *lower_bound(x);",
          "    return l.k * x + l.m;",
          "  }",
          "};",
        ],
        "description": "Line Container"
    },
    "nttmult": {
      "prefix": "ntt",
      "body": [
        "namespace NTT{",
        "    using ll = long long;",
        "    const ll mod = 998244353;",
        "        inline ll pw(ll x, ll n) {",
        "        ll ret = 1, pv = x;",
        "        for(; n; n >>= 1){",
        "            if(n & 1) ret = ret * pv % mod;",
        "            pv = pv * pv % mod;",
        "        }",
        "        return ret;",
        "    }",
        "",
        "    inline ll multInv(ll x){",
        "        return pw(x, mod - 2);",
        "    }",
        "    void ntt(vector<ll>& a, bool inv){",
        "        const int w = 3; //for mod = 998244353",
        "        int n = szz(a), j = 0;",
        "        vector<ll> roots(n/2);",
        "        for(int i = 1; i < n; i++){",
        "            int b = (n >> 1);",
        "            while(j >= b) {",
        "                j -= b; b >>= 1;",
        "            }",
        "            j += b;",
        "            if(i < j) swap(a[i], a[j]);",
        "        }",
        "        ll ang = pw(w, (mod - 1) / n);",
        "        if(inv) ang = pw(ang, mod - 2);",
        "        for(int i = 0; i < n / 2; i++){",
        "            roots[i] = (i ? roots[i-1] * ang % mod : 1);",
        "        }",
        "        for(int i = 2; i <= n; i <<= 1){",
        "            int step = n / i;",
        "            for(int j = 0; j < n; j += i){",
        "                for(int k = 0; k < i / 2; k++){",
        "                    ll u = a[j + k], v = a[j + k + i/2] * roots[step * k] % mod;",
        "                    a[j + k] = (u + v) % mod;",
        "                    a[j + k + i/2] = (u + mod - v) % mod;",
        "                }",
        "            }",
        "        }",
        "        ll ninv = multInv(n);",
        "        if(inv) for(int i = 0; i < n; i++) a[i] = a[i] * ninv % mod;",
        "    }",
        "",
        "    vector<ll> mult(vector<ll> &a, vector<ll> &b){",
        "        vector<ll> fa(all(a)), fb(all(b));",
        "        int n = 2; while(n < szz(a) + szz(b)) n <<= 1;",
        "        fa.resize(n); fb.resize(n);",
        "        ntt(fa, false); ntt(fb, false);",
        "        for(int i = 0; i < n; i++) fa[i] = fa[i] * fb[i] % mod;",
        "        ntt(fa, true);",
        "        return fa;",
        "    }",
        "}"
      ],
      "description": "nttmult"
    }
}